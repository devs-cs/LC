{"id":867309447,"lang":"java","lang_name":"Java","time":"5 months, 2 weeks","timestamp":1672290905,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/867309447/","is_pending":"Not Pending","title":"Poor Pigs","memory":"N/A","code":"class Solution {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int trials = minutesToTest/minutesToTest;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < 1000; i++) //num pigs\n        {\n            int pigs = i;\n            int val = 1;\n            for(int t = 0; t < trials-1; t++)\n            {\n                if(pigs > 0)\n                    val *= (pigs);\n                pigs--;\n            }\n            val = (int) Math.round(Math.pow(2, pigs) * val);\n            System.out.println(i + \"pigs, search \" + val);\n            if(val >= buckets)\n                return i;\n        }\n        return (-1);\n\n    }\n}\n        //optimal strat is to use pigs and bin search\n        //each trial we can use n pigs to divide by n\n        //if we need to find 1 in k, it takes log(k)\n\n        //each division takes n\n\n        // if buckets = 10, and trials = 2, \n        /*\n        t1: 3 pigs used\n        2 remaining\n        max: 4 to search, requires 2. \n\n        so final amount of pigs used is p can search a total of \n        prod(2^p * (p*1) + (p*2)) searched with p+2 total pigs. \n\n        Ok so for a number k buckets. with t trials, \n\n        we binary search on values that might work (or just brute force for now),\n\n    works if TP * (TP-1) * ... (TP-trials + 1) * 2^(TP-trials)\n\n\n\n\n\n        */\n        // 1 2 3 4 5 6 7 8 \n        // 1 2 3 4\n        // 1 3 5 7\n        // 1 2 5 6 ","compare_result":"110010100111111000","title_slug":"poor-pigs","has_notes":false}