{"id":960696595,"lang":"cpp","lang_name":"C++","time":"1 week, 6 days","timestamp":1685508732,"status":10,"status_display":"Accepted","runtime":"2342 ms","url":"/submissions/detail/960696595/","is_pending":"Not Pending","title":"Word Ladder","memory":"17.6 MB","code":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        int n = wordList.size() + 1;\n        wordList.push_back(beginWord); \n        vector<vector<int>> adjList(n);\n        bool found = false;\n        for(int i = 0; i < n; i++)\n        {\n            if (wordList[i] == endWord)\n                found = true;\n        }\n        if(!found) return 0;\n        for(int i = 0; i < n; i++) //could tech do this in 26*wordLen * log(n)\n        {\n            for(int j = i+1; j < n; j++)\n            {\n                bool diff = false;\n                bool edge = true;\n                for(int k = 0; k < beginWord.length(); k++)\n                {\n                    \n                    if(wordList[i][k] != wordList[j][k] && diff)\n                        edge =  false;\n                    else if (wordList[i][k] != wordList[j][k]) \n                        diff = true;\n                }\n                if(edge){\n                adjList[i].push_back(j);\n                adjList[j].push_back(i);\n                }\n            }\n        }\n        map<string, int> m;\n        for(int i = 0; i < n; i++)\n            m[wordList[i]] = i;\n        queue<int> q;\n        q.push(m[beginWord]);\n        vector<bool> seen (n, false);\n        seen[m[beginWord]] = true;\n        int count = 0;\n        vector<int> dist (n);\n        dist[m[beginWord]] = 0;\n        while(!seen[m[endWord]] && !q.empty())\n        {\n            \n            count++;\n            int pos = q.front();\n            // cout << pos << endl;\n            cout << wordList[pos] << \"TEST\" << endl;\n            q.pop();\n            for(int i = 0; i < adjList[pos].size(); i++)\n            {\n                if(seen[adjList[pos][i]]) continue;\n                q.push(adjList[pos][i]);\n                dist[adjList[pos][i]] = dist[pos] + 1;\n                cout <<  wordList[adjList[pos][i]]<< endl;\n                seen[adjList[pos][i]] = true;\n            }\n        }\n        if(q.empty() && !seen[m[endWord]])\n            return 0;\n        return dist[m[endWord]]+1;\n  \n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"word-ladder","has_notes":false}